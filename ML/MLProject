import cv2 #여기선 OpenCV가 cv2
import time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import tensorflow as tf
from tensorflow import keras
from keras.src.ops.image import gaussian_blur

mnist = keras.datasets.mnist
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

train_images = train_images / 255.0
test_images = test_images / 255.0

model = keras.Sequential([
    keras.layers.Input(shape=(28, 28)),
    keras.layers.Flatten(),
    keras.layers.Dense(256, activation='relu'),
    keras.layers.Dropout(0.3),      #과적합 방지용 Test
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dropout(0.2),
    keras.layers.Dense(56, activation='relu'),
    keras.layers.Dropout(0.1),
    keras.layers.Dense(10, activation='softmax')
])
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
model.fit(train_images, train_labels, epochs=10, verbose=1)
model.save('my_first_DNN_model.keras')
load_model = keras.models.load_model('my_first_DNN_model.keras')
#%%
game_clear = False
clear_time = None

def numst(usernum,unit):
    status = []
    for i in range(unit):
        if i < len(usernum):
            status.append(str(usernum[i]))
        else:
            status.append('_')
    return ' '.join(status)
unit=3 #몇자리할건지
rannums = np.random.choice(10, size=unit, replace=False) #랜덤 숫자 3자리
print("랜덤번호 : ",rannums)
usernum=[]
history=[]
cornum = ' '.join(str(n) for n in rannums)

cap=cv2.VideoCapture(0)
if not cap.isOpened():
    print("Wep Cam을 열 수 없습니다.")
    exit()

while True:
    ret, frame = cap.read() #리턴과 프레임
    if not ret:
        print("프레임을 가져올 수 없습니다.")
        break
    flip_frame=cv2.flip(frame,1) #화면 뒤집기
    height, width, _ = frame.shape #중앙찾기
    center_x, center_y = width//2, height//2 #중앙값
    roi = flip_frame[center_y-150 : center_y+150, center_x-150 : center_x+150]

    #정답 맞추기 전까지 (기존 프레임)
    if not game_clear:
        cv2.rectangle(flip_frame,(center_x-150, center_y-150),(center_x+150, center_y+150),(0,0,255),2)
        # 현재 입력
        status_text = numst(usernum, unit)
        cv2.putText(flip_frame,f"INPUT : {status_text}",(10, 30),cv2.FONT_HERSHEY_TRIPLEX,1.0,(219, 152, 52),2)
        # 시도 기록
        start_y = 70
        line_height = 30
        for i, text in enumerate(history[-3:]):
            cv2.putText(flip_frame,text,(10, start_y + i * line_height),cv2.FONT_HERSHEY_TRIPLEX,0.5,(15, 196, 241),1)

    #정답을 맞췄을 경우 표시(기존 프레임X)
    if game_clear:
        # CLEAR
        cv2.putText(flip_frame,"CLEAR",(center_x - 160, center_y - 20),cv2.FONT_HERSHEY_TRIPLEX,3.0,(0, 255, 0),5)
        # 정답
        cv2.putText(flip_frame,f"PW : {cornum}",(center_x - 120, center_y + 50),cv2.FONT_HERSHEY_TRIPLEX,0.8,(255, 255, 255),2)
        # 5초후 종료
        if time.time() - clear_time >= 5:
            break

    cv2.imshow("Webcam",flip_frame)
    # 화면 캡쳐용 키값 받기
    key=cv2.waitKey(1) & 0xFF
    if key == ord('c') or key == ord('C'): #c 버튼을 누르면 캡쳐
        gray_image = cv2.cvtColor(roi,cv2.COLOR_BGR2GRAY) #회색 화면으로 이진화
        gray_image=np.flip(gray_image,1) #좌우 반전 시킴
        cv2.imwrite("gray_image.png",gray_image) #저장 - 이제 이진화가 필요함
        gaussian_blur=cv2.GaussianBlur(gray_image,(5,5),3) #가우시안 블러를 사용
        _, otsu_thread=cv2.threshold(gaussian_blur,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU) #OTSU가 자동으로
        cv2.imshow("otsu_thread",otsu_thread)
        ### Morph
        kernel=np.ones((5,5),np.uint8)
        erosion=cv2.erode(otsu_thread,kernel,iterations=5)
        cv2.imshow("erosion",erosion)
        cv2.imwrite("digit_binary_image.png",erosion)
        img=cv2.imread("digit_binary_image.png",cv2.IMREAD_UNCHANGED)

        # 이미지 순서 otsu -> erosion(침식) -> cropped(필요영역 제외 제거) -> reversed(흑백반전)
        # 이미지 자르기
        h,w=img.shape[:2]
        crop_size=280
        cx, cy=w//2,h//2
        half=crop_size//2
        x1,x2=cx-half, cx+half
        y1,y2=cy-half, cy+half
        #경계면 설정
        x1=max(0,x1)
        y1=max(0,y1)
        x2=min(w,x2)
        y2=min(h,y2)

        cropped_img=img[y1:y2,x1:x2]
        cv2.imshow("cropped_img",cropped_img)

        ### 현재 이미지는 회색배경에 검은색 글씨이므로 목표인 검정배경 흰색 글씨와 다르기에 반전해줘야한다.
        reversed_img=cv2.bitwise_not(cropped_img)
        cv2.imshow("reversed_img",reversed_img)
        cv2.imwrite("IMAGE_FOR_TEST.png",reversed_img)

        reversed_img=cv2.resize(reversed_img,(28,28))

        reversed_img=reversed_img/255
        plt.imshow(reversed_img,cmap='gray')
        pred = model.predict(reversed_img[np.newaxis, :, :])[0]
        for i, p in enumerate(pred):
            if round(p, 4) == 0:
                continue
            print(f"{i}: {p:.4f}")
        print("인식된 숫자 :", np.argmax(pred))
        num = np.argmax(pred)
        usernum.append(num)
        if len(usernum) == unit:
            strike=0
            ball=0
            for i in range(unit):
                if usernum[i] == rannums[i]:
                    strike += 1
                elif usernum[i] in rannums:
                    ball += 1

            #history : 시도한 기록을 저장합니다.
            tryhistory=f"{[int(n) for n in usernum]} : {strike}S {ball}B"
            history.append(tryhistory)

            print(f"{[int(n) for n in usernum]} : {strike} Strike, {ball} Ball")
            print("-" * 20)
            if strike == unit:
                print("정답입니다")
                game_clear = True
                clear_time = time.time()
            usernum.clear()# 재시도를 위해 초기화
    elif key == 27: #esc를 누르면 종료
        break
cap.release()
cv2.destroyAllWindows()
